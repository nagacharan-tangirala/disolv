use crate::bucket::{Bucket, TimeStamp};
use crate::response::Queryable;

/// A trait to indicate a type that can be used to represent the transfer status of a payload.
pub trait PayloadStatus: Clone + Send + Sync {}

/// A trait that represents the content of a payload. Extend this to a custom type (e.g. struct)
/// that you want to use as a content generated by a device. Each device type can have its own
/// payload content type. The only requirement is that the type must contain some data that can be
/// <code>Queryable</code>. This allows content to be queried by other devices.
pub trait PayloadContent<Q>: Copy + Clone + Send + Sync
where
    Q: Queryable,
{
}

/// A trait that represents the metadata of a payload. Extend this to a custom type (e.g. struct)
/// that contains the metadata such as the size, count, etc. of a payload. The struct extending
/// this trait must contain information that is useful to evaluate if the transmission is feasible.
pub trait PayloadMetadata: Clone + Send + Sync {}

/// A generic struct that represents a payload of a device. A message exchange between two devices
/// can be represented by a payload. Gathered content can be used to represent the aggregated
/// content from the downstream devices that require forwarding.
#[derive(Clone, Debug, Default)]
pub struct GPayload<C, M, Q>
where
    C: PayloadContent<Q>,
    M: PayloadMetadata,
    Q: Queryable,
{
    pub content: C,
    pub metadata: M,
    pub gathered_content: Option<Vec<C>>,
    _phantom: std::marker::PhantomData<fn() -> Q>,
}

impl<C, M, Q> GPayload<C, M, Q>
where
    C: PayloadContent<Q>,
    M: PayloadMetadata,
    Q: Queryable,
{
    pub fn new(content: C, payload_stats: M, gathered_data: Option<Vec<C>>) -> Self {
        Self {
            gathered_content: gathered_data,
            content,
            metadata: payload_stats,
            _phantom: std::marker::PhantomData,
        }
    }
}

/// A trait that an entity must implement to transmit payloads. Transmission of payloads
/// can be flexibly handled by the entity and can transfer payloads to devices of any tier.
/// This should be called in the <code>uplink_stage</code> method of the entity.
pub trait Transmitter<B, C, M, Q, T>
where
    B: Bucket<T>,
    C: PayloadContent<Q>,
    M: PayloadMetadata,
    Q: Queryable,
    T: TimeStamp,
{
    fn collect(&mut self, bucket: &mut B) -> Vec<GPayload<C, M, Q>>;
    fn payloads_to_forward(&mut self, payloads: Vec<GPayload<C, M, Q>>) -> Vec<GPayload<C, M, Q>>;
    fn compose(&mut self, payloads: Vec<GPayload<C, M, Q>>) -> GPayload<C, M, Q>;
    fn transmit(&mut self, payload: GPayload<C, M, Q>, bucket: &mut B);
}

use crate::bucket::Bucket;
use crate::entity::{Kind, Tier};
use crate::radio::Action;
use hashbrown::HashMap;
use typed_builder::TypedBuilder;

/// A trait to represent a type that can be used to query content from other devices.
pub trait Queryable: Copy + Clone + PartialEq + Eq + Send + Sync {}

/// A trait to represent a type that can be used to represent the individual content of
/// a payload. Extend this to a custom type (e.g. struct) that you want to use as a collection
/// of data that is being transferred by a device.
pub trait DataUnit: Clone + Send + Sync {
    type Action: Action;
    fn size(&self) -> f32;
    fn count(&self) -> u32;
    fn action(&self) -> Self::Action;
    fn set_action(&mut self, action: Self::Action);
}

/// A trait that represents the content of a payload. Extend this to a custom type (e.g. struct)
/// that you want to use as a content generated by a device. Each device type can have its own
/// payload content type.
pub trait NodeState: Copy + Clone + Send + Sync {}

/// A trait that represents the metadata of a payload. Extend this to a custom type (e.g. struct)
/// that contains the metadata such as the size, count, etc. of a payload. The struct extending
/// this trait must contain information that is useful to evaluate if the transmission is feasible.
/// It should contain information about the queryable content of the payload.
pub trait Metadata: Clone + Send + Sync {}

/// A generic struct that represents a payload of a device. A message exchange between two devices
/// can be represented by a payload. Gathered content can be used to represent the aggregated
/// content from the downstream devices that require forwarding.
#[derive(Clone, Debug, Default, TypedBuilder)]
pub struct GPayload<M, N>
where
    M: Metadata,
    N: NodeState,
{
    pub node_state: N,
    pub metadata: M,
    pub gathered_states: Option<Vec<N>>,
}

/// A trait to indicate a type that can be used to represent the transfer status of a payload.
pub trait PayloadStatus: Clone + Send + Sync {
    fn as_u8(&self) -> u8;
}

/// A trait that an entity must implement to transmit payloads. Transmission of payloads
/// can be flexibly handled by the entity and can transfer payloads to devices of any tier.
/// This should be called in the <code>uplink_stage</code> method of the entity.
pub trait Transmitter<B, M, N>
where
    B: Bucket,
    M: Metadata,
    N: NodeState,
{
    type NodeTier: Tier;
    type NodeKind: Kind;

    fn collect(&mut self, bucket: &mut B) -> Vec<GPayload<M, N>>;
    fn compose(
        &mut self,
        target_tier: &Self::NodeTier,
        to_fwd: &Vec<GPayload<M, N>>,
    ) -> Option<GPayload<M, N>>;

    fn transmit(&mut self, target_kind: &Self::NodeKind, payload: GPayload<M, N>, bucket: &mut B);
}

/// A trait to indicate a type that can be used to convey the payload transfer status back
/// to the device that sent the payload.
///
/// Metadata can contain transfer metrics such as the status, latency, etc.
pub trait TxStatus: Clone + Send + Sync {}

/// A trait to indicate a type that can be used to represent the content of a response. The content
/// can contain queries that can be read by other devices.
pub trait Reply: Clone + Send + Sync {}

/// A generic struct that represents a response from a device. A response can be used to relay
/// queries and payload transfer metrics to other devices after they send a payload.
///
/// Queries can be optionally included in the response to control the content that is
/// being transferred.
#[derive(Clone, Debug, Default, TypedBuilder)]
pub struct GResponse<R, T>
where
    R: Reply,
    T: TxStatus,
{
    pub reply: R,
    pub downstream: Option<Vec<R>>,
    pub tx_status: T,
}

/// A trait that an entity must implement to respond to payloads. Transmission of payloads
/// can be flexibly handled by the entity transfer payloads to devices of any tier.
/// This should be called in the <code>downlink_stage</code> method of the entity.
pub trait Responder<B, R, T>
where
    B: Bucket,
    R: Reply,
    T: TxStatus,
{
    fn receive(&mut self, bucket: &mut B) -> Option<GResponse<R, T>>;
    fn respond(&mut self, response: Option<GResponse<R, T>>, bucket: &mut B);
}
